# Лабораторная работа №2 (звёздочка*)

## Задание:
Написать “плохой” Docker compose файл, в котором есть не менее трех “bad practices” по их написанию

Написать “хороший” Docker compose файл, в котором эти плохие практики исправлены

В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. 

В отчете описать, как этого добились и кратко объяснить принцип такой изоляции

## Ход работы:
### 1. Создадим директорию для проекта и перейдем в нее
`mkdir lab2-docker-compose`

`cd lab2-docker-compose`

### 2. Создаем "плохой" docker-compose файл
`nano docker-compose-bad.yml`

Содержимое файла:

<img width="677" height="450" alt="image" src="https://github.com/user-attachments/assets/5de55694-138c-4602-bb46-382f91159b64" />

#### Почему это плохо:

1. Использование тега 'latest' : тег 'latest' всегда указывает на последнюю собранную версию образа. Это может привести к непредсказуемому поведению, так как при очередном запуске может подняться новая версия, которая сломает совместимость.

2. Хранение секретов в открытом виде в compose-файле :  пароли и другие секреты, записанные прямо в файле, могут быть случайно закоммичены в репозиторий и стать доступными злоумышленникам.

3.  Использование bind mount текущей директории : bind mount текущей директории может привести к проблемам производительности (особенно на Windows и macOS) и к тому, что изменения на хосте сразу влияют на контейнер, что может быть нежелательно. Также это может привести к перезаписи файлов в контейнере файлами с хоста, если они не синхронизированы.

### 3. Создаем файл с переменными окружения
`nano .env`

Туда вписываем:

`DB_PASSWORD=secret_secure_password`

`POSTGRES_PASSWORD=postgres_secret_password`

<img width="673" height="199" alt="image" src="https://github.com/user-attachments/assets/80968120-aa68-4de6-a976-d258fae9457f" />

То есть мы вынесли в отдельный файл все  настройки и секретные данные, которые не должны попадать в код.

### 4. Создаем "хороший" docker-compose файл

`nano docker-compose-good.yml`

Содержимое файла:

<img width="673" height="479" alt="image" src="https://github.com/user-attachments/assets/1a66ac5c-f023-40e8-b54a-991b6b58555b" />

#### Исправления:

1. Использование тега 'latest' : тег 'latest' всегда указывает на последнюю собранную версию образа. Это может привести к непредсказуемому поведению, так как при очередном запуске может подняться новая версия, которая сломает совместимость. В хорошем файле мы используем конкретные версии (теги)
образов, например, 'nginx:1.21-alpine" и 'postgres:13-alpine'. Это гарантирует, что мы всегда используем одну и ту же версию.


2. Хранение секретов в открытом виде в compose-файле :  Мы вынесли секреты в файл ' .env, который добавлен в
﻿gitignore'. B compose-файле мы используем директиву 'env_file' для подключения этого файла.

3.  Использование bind mount текущей директории : мы заменили bind mount на именованный volume. Это улучшает производительность и изолирует данные. Однако, если нужно делиться кодом для разработки, то bind mount оправдан, но для прода лучше использовать копирование в образ при сборке.

### 5. Создаем файл с сетевой изоляцией
`nano docker-compose-isolated.yml`

Содержимое файла:

<img width="666" height="512" alt="image" src="https://github.com/user-attachments/assets/b613fb3e-30fa-4876-aeab-c82825fe08a8" />

Мы настроили сетевую изоляцию так, что сервисы 'web' и 'db' не видят друг друга. Это достигнуто путем размещения каждого сервиса в своей собственной сети ( 'web_network' И "db_network"). Поскольку эти сети не соединены, контейнеры не могут общаться.


### 6. Тестируем

#### Тестируем изолированную версию:

`docker ps`

`docker exec my_app ping db`

`curl http://localhost:80`


<img width="1004" height="209" alt="image" src="https://github.com/user-attachments/assets/8a9fbbc4-6227-44a1-8bfb-26b27aba7ce6" />

То есть мы видим, что оба контейнера запущены, но припопытке пингования у нас возникает ошибка, тк контейнеры находятся на рахных сетях и dns не может разрешить имя db. Это доказывает, что изоляция работает.

При этом, при проверке nginx, получаем ответ, следовательно он работает и отвечает на запросы корректно.


#### Тестируем обычную версию:

`docker-compose -f docker-compose-isolated.yml down`

`docker-compose -f docker-compose-good.yml up -d`

`docker exec my_app ping db`

`docker-compose -f docker-compose-good.yml down`


<img width="650" height="429" alt="image" src="https://github.com/user-attachments/assets/5a499185-3432-45bb-96c4-198cf41770c8" />


То есть, мы запускаем обычные контейнеры, запускаем их и настраиваем сетевое подключение. Видим, что ping сработал корректно, следовательно сеть настроена. 
