# Лабораторная работа №2

## Задание:
- Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов
- Написать “хороший” Dockerfile, в котором эти плохие практики исправлены
- В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
- В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Решение:
1. **Использование latest**
```
FROM ubuntu:latest
```
Тег недетерминирован. Версия может измениться

Исправлено на:
```
FROM python:3.9-slim
```
Конкретная версия. Легкий пакет.

2. **Множественные RUN команды**
```
RUN apt-get update -y
RUN apt-get install -y python3 python3-pip
RUN python3 -m pip install --break-system-packages flask
```
Каждый RUN создает новый слой, тем самым увеличвает размер образа.

Исправлено на:
```
RUN pip install --no-cache-dir -r requirements.txt
```
Один слой для зависимостей.

3. **Копирование кода до установки зависимостей**
```
COPY . /app
WORKDIR /app
```
При любом изменении кода сбрасывается кэш слоев с зависимостями

Исправлено на:
```
COPY requirements.txt .
```
Сначала requirements.txt для кэширования зависимостей. Потом весь код

## 2 плохие практики при работе с докер файлами
1. **Уязвимости безопасности**
```
docker run -d -p 80 my-app-image
docker run -d -p 3000-4000:3000-4000 development-image
```
Конфликты портов - несколько контейнеров пытаются занять одни порты. Нарушение изоляции - контейнеры видят сетевую активность хоста.

2. **Принудительное удаление**
```
# Запуск без health checks
docker run -d my-app-image

# Принудительное удаление 
docker rm -f container-name
```
Нет самовосстановления - контейнер может "зависнуть" и продолжать работать. Потеря данных - принудительное завершение может повредить данные


